So sieht das aus was da mit sage gemacht wird. also das orbit finden ist damit anscheinend kein problem.
was ich nicht verstehe ist wie die punkte in der b matrix eingefärbt sind. also warum die erste spalte zu neim cluster mit nur einem knoten gehört.
aus den orbits sollte das ja die letzte sein.. bzw wie da umsortiert wird bei der berechnung von B.


from networkIRR import *
import sage.all as sg
import numpy
# an example adjacency matrix
Aij32=numpy.array([[0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
                [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1],
                [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1],
                [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1],
                [0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0],
                [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],
                [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0],
                [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0]])



                
# create a networkIRR object for the adjacency matrix
data32=NetworkIRR(Aij32)
# get clusters
A=data32.get_adjacency_matrix()
B=sg.Matrix(A)

print "the orbits are:"
print data32.get_orbits()

print "the number of symmetries is",data32.get_automorphism_group().order()

# generate T matrix
tmat=data32.get_transformation_operator()
print "the T matrix:"
#print T matrix
for row in tmat:
    printstring=""
    for x in row:
        wch=str(round(real(x),2))
        printstring=printstring+wch+" "*(int(6)-len(wch))

    printstring=printstring+"\n"
    print printstring
    
# generate B matrix
tinv=la.inv(tmat)
b=np.dot(tmat,np.dot(Aij32,tinv))

print "the B matrix:"
for row in b:
    printstring=""
    for x in row:
        wch=str(round(real(x),2))
        printstring=printstring+wch+" "*(int(6)-len(wch))
    printstring=printstring+"\n"
    print printstring




///
the orbits are:
[[0, 7], [1, 2, 6, 8], [3, 5], [4, 9], [10]]
the number of symmetries is 32
the T matrix:
-0.0  0.0   -0.0  0.0   -0.71 0.0   0.0   0.0   0.0   -0.71 -0.0  

0.0   0.0   0.0   -0.71 0.0   -0.71 -0.0  0.0   0.0   0.0   0.0   

0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   1.0   

-0.71 0.0   -0.0  0.0   -0.0  0.0   0.0   -0.71 0.0   0.0   -0.0  

0.0   -0.5  -0.5  0.0   0.0   0.0   -0.5  0.0   -0.5  0.0   0.0   

-0.0  -0.0  -0.0  -0.71 0.0   0.71  -0.0  -0.0  -0.0  -0.0  -0.0  

-0.0  -0.5  0.5   -0.0  -0.0  -0.0  -0.5  -0.0  0.5   -0.0  -0.0  

-0.0  0.0   -0.0  -0.0  -0.71 0.0   -0.0  0.0   -0.0  0.71  -0.0  

-0.71 0.0   -0.0  -0.0  -0.0  -0.0  -0.0  0.71  -0.0  -0.0  -0.0  

-0.0  -0.0  0.71  0.0   0.0   -0.0  0.0   -0.0  -0.71 -0.0  -0.0  

-0.0  -0.71 0.0   0.0   -0.0  -0.0  0.71  -0.0  0.0   -0.0  -0.0  

the B matrix:
1.0   2.0   0.0   1.0   2.83  -0.0  -0.0  -0.0  -0.0  0.0   0.0   

2.0   1.0   -1.41 2.0   2.83  -0.0  -0.0  -0.0  -0.0  0.0   -0.0  

0.0   -1.41 0.0   -1.41 -2.0  0.0   0.0   0.0   0.0   0.0   0.0   

1.0   2.0   -1.41 1.0   2.83  -0.0  -0.0  -0.0  -0.0  0.0   0.0   

2.83  2.83  -2.0  2.83  2.0   -0.0  -0.0  -0.0  -0.0  -0.0  0.0   

0.0   0.0   -0.0  0.0   0.0   -1.0  0.0   -0.0  -0.0  0.0   0.0   

0.0   0.0   0.0   0.0   0.0   0.0   -2.0  0.0   0.0   0.0   0.0   

0.0   0.0   0.0   0.0   0.0   -0.0  -0.0  -1.0  -1.0  0.0   0.0   

0.0   0.0   -0.0  0.0   0.0   -0.0  -0.0  -1.0  -1.0  0.0   0.0   

0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   

0.0   0.0   -0.0  0.0   0.0   -0.0  -0.0  -0.0  -0.0  0.0   0.0   








Dreadnaut:
n=11 g 1 2 3 5 6 7 8 9 10 ;0 2 3 4 5 7 8 9 10 ;0 1 3 4 5 6 7 9 10 ;0 1 2 4 5 6 7 8 9 10 ;1 2 3 5 6 7 8 9 ;0 1 2 3 4 6 7 8 9 10 ;0 2 3 4 5 7 8 9 10 ;0 1 2 3 4 5 6 8 10 ;0 1 3 4 5 6 7 9 10 ;0 1 2 3 4 5 6 8 ;0 1 2 3 5 6 7 8 ;



gibt auch die generators aus. daraus die matrizen ist einfach.